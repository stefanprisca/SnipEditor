grammar org.eclipse.recommenders.templates.rcp.SnipDSL with org.eclipse.xtext.xbase.Xbase 
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate snipDSL "http://www.eclipse.org/recommenders/templates/rcp/SnipDSL"

domainmodel:
	importSection=jFaceImportSection?
	entity=entity? 
	//features+=EntityFeature*
    body=dModelBody
	
;
/*Import section used to enable imports of the following format:
 * ${imp:import(imp1, imp2, ..)}
 * TODO: no coma is required between imports! Fix IT!
 */
jFaceImportSection returns xtypes::XImportSection:
	
	'${'('imp'':')?
	'import'
	'(' XImportSection')}'
;

XImportDeclaration returns xtypes::XImportDeclaration:
	','?
	(importedType=[types::JvmDeclaredType|QualifiedName] 
		| importedNamespace=QualifiedNameWithWildcard)
		
;


/*
 * Body for the whole domain model. Enables to treat the domain model as a class
 */
dModelBody returns xbase::XBlockExpression:
{xbase::XBlockExpression}
	(expressions += abstractElement) *
;


abstractElement returns xbase::XExpression:
	packageDeclare | 
	entity|
	helpperClassAnnotation | 
	method |
	XExpressionInsideBlock 
;

packageDeclare:
	'package' name = QualifiedName '{'
	(elements += abstractElement)*
	'}'
;


entity:
	(visibility=Visibility)? 'class' name = ValidID 
		('extends' jType=abstractTypeName  )?
	'{'
		features += EntityFeature*
	
	'}'
;


EntityFeature returns xbase::XExpression:
	jFaceVariableDeclaration ";" | method 

;

method:
	(visibility=Visibility)? 'static'?  (jType=abstractTypeName | "void")
	name=ValidID'('(params+=FullJvmFormalParameter
		(','params+=FullJvmFormalParameter)*)?')' 
		('throws' throwExceptions+=operandID(',' throwExceptions+=operandID)*)?
	body=XBlockExpression
;
//attribute assignments
attributeAssignment returns xbase::XExpression:
	 blockAssignment | XLiteral |=>XExpression
;
//assignment with {...}
blockAssignment returns xbase::XExpression:
	{blockAssignment}
	"{" (values+=XLiteral (',' values+=XLiteral)*)? "}"
;


//attribute declaration -> replaced with jFaceVarDeclaration
/*attributeDeclaration :
	(visible=Visibility)? 'static'? (jType=abstractTypeName|jfaceType=jFaceDeclarationType '[]'?)
	name = declarativeID ('=' value=XExpression)? 
;*/

//features that are present in the block
XExpressionInsideBlock  returns xbase::XExpression :
 			(jFaceVariableDeclaration | 
 			 XExpression
 			) ';'?
;
/*Changed the name to simpleName as the type computation asked for a simple name
 * Check XVariableDeclaration.getSimpleName();
 */
jFaceVariableDeclaration returns xbase::XVariableDeclaration:
	{jFaceVariableDeclaration}
	(visible=Visibility)? static='static'? ( writeable?='final')? (jType=abstractTypeName) arrayType='[]'?
	simpleName=declarativeID ('=' right=attributeAssignment)?
	
;



XExpression returns xbase::XExpression :
	UnaryOperation
;
 UnaryOperation returns xbase::XExpression:
	{UnaryOperation}
	operand=jFaceExpression feature=UnaryOperand
	|=>jFaceSpecificLiteral
;

/*Append special jFace expression to the grammar
 * this expression will be resolved in the typecomputer to their specific type
 * TODO: eval the rest of expressions to their proper type
 */
  
jFaceExpression returns xbase::XExpression:
	{jFaceExpression}
	( '${' (
		value=JFACEEXPRID '}'| 
		ValidID ':' value = ('var' | 'localVar' |'field' ) 
		'(' types+=JvmTypeReference (',' types+=JvmTypeReference)*')}' 
		|ValidID ':' value='link' '('links+=QualifiedName(','links+=QualifiedName)*')}'
		|ValidID ':' value='argType' '('arg=IdOrSuper   /*[types::JvmIdentifiableElement|IdOrSuper]*/ ',' typeArg=INT')}'
		)) //=>('.' feature=XExpression)?
	//|=>jFaceSpecificLiteral
	;
/*JFace cast expression : supports casts to jface types
 * e.g: ${array}
 */
jFaceCastExpression returns xbase::XExpression:
	{jFaceCastExpression}
 '('(type=jFaceDeclarationType | javaType=abstractTypeName)')' target=XExpression
 |=> AssignmentWithClosure
;
/**
 * unary operation
 */



/*
 *Assignment that changes the XAssignment to support [] closure 
 * for operands.
 * Does not offer scoping for local scope variables (variables inside a method body)
 * TODO: Implement JvmIdentifiableElement as feature!
 */
AssignmentWithClosure returns xbase::XExpression:
	{AssignmentWithClosure}
	(feature=FeatureCallID 
	closure=XClosure (OpSingleAssign|OpMultiAssign) value=XAssignment
	) |=>XAssignment
;




/*
 * Note: Writable means final!
 *-> Replaced with jFaceVariableDeclaration 
 
XVariableDeclaration returns xbase::XExpression:
	{xbase::XVariableDeclaration}
	( writeable?='final')? (type=abstractTypeName) name=declarativeID ('=' right=attributeAssignment)?
;

*/



XPrimaryExpression returns xbase::XExpression:
	ConstructorCall |
	XBlockExpression |
	XSwitchExpression |
	AbstractFeatureCall |
	XLiteral |
	XIfExpression |
	ForLoopExpression |
	XWhileExpression |
	XDoWhileExpression |
	XThrowExpression |
	XReturnExpression |
	XTryCatchFinallyExpression |
	XParenthesizedExpression;

ConstructorCall returns xbase::XExpression:
	jFaceConstructorCall | XConstructorCall
;


AbstractFeatureCall returns xbase::XExpression:
	FeatureCallWithClosure |
	jFaceExpression|
	XFeatureCall
;

/*
 * Feature call that supports [] closure
 */
FeatureCallWithClosure:
	feature=XFeatureCall closure=XClosure
;
/*Constructor call for jface types */
jFaceConstructorCall:
	{jFaceConstructorCall}
	'new' (constructor=(jFaceDeclarationType|abstractTypeName))
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	((=>'(' 
		(
		  arguments+=XExpression (',' arguments+=XExpression)*
		)? 
	')') |=> arguments+=XClosure)
	('{'
		arguments+=EntityFeature*
		'}'
	)?
	;



XConstructorCall returns xbase::XExpression:
	
	{xbase::XConstructorCall}
	'new' constructor=[types::JvmConstructor|ValidID] 
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	((=>'(' 
		(
		  arguments+=XExpression (',' arguments+=XExpression)*
		)? 
	')') |=> arguments+=XClosure)
	arguments+=XBlockExpression?
	('{'
		arguments+=EntityFeature*
		'}'
	)?
	;
 /*
 * Overridden to eliminate lambda expression 
 * This expressions were conflicting with [] closure, and java has no lambda expressions
 */
XFeatureCall returns xbase::XExpression:
	{xbase::XFeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	(feature=[types::JvmIdentifiableElement|IdOrSuper])  
	(=>explicitOperationCall?='(' 
		(
		 	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
		)? 
	')')?
	;



XMemberFeatureCall returns xbase::XExpression:
	XPrimaryExpression
	(=>({xbase::XAssignment.assignable=current} ('.'|explicitStatic?="::") (feature=[types::JvmIdentifiableElement|FeatureCallID] )OpSingleAssign) value=XAssignment
	|=>({xbase::XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		(feature=[types::JvmIdentifiableElement|FeatureCallID]) (
			=>explicitOperationCall?='(' 
				(
				   	memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
				)? 
			')')?
		)*;





ForLoopExpression returns xbase::XExpression:
	ClassicForLoopExpression | XForLoopExpression
;


UnaryOperand:
	"!" | "--" | "++";


ClassicForLoopExpression:
	//{ClassicForLoopExpression}
	'for' '(' 
	(declaredParam=JvmFormalParameter ('=' value=XAssignment)?)?';' 
				(condition=XExpression)? ';' 
				(forExpression=XExpression)?
		')'
		eachExpression=XExpression
;



XForLoopExpression returns xbase::XExpression:
	{xbase::XForLoopExpression}
	'for' '(' declaredParam=(FullJvmFormalParameter|JvmFormalParameter) ':' forExpression=XExpression ')'
		eachExpression=XExpression
;

XIfExpression returns xbase::XExpression:
	{xbase::XIfExpression}
	'if' '(' if=XExpression ')'
	then=XExpression
	(=>'else' else=XExpression)?
	|{xbase::XIfExpression}
	=>'else' else=XExpression;

XTryCatchFinallyExpression returns xbase::XExpression:
	{xbase::XTryCatchFinallyExpression}
	'try' 
		expression=XExpression
	(
		catchClauses+=XCatchClause+
		(=>'finally' finallyExpression=XExpression)?
	|	'finally' finallyExpression=XExpression
	)
	|{xbase::XTryCatchFinallyExpression}
	(
		catchClauses+=XCatchClause+
		(=>'finally' finallyExpression=XExpression)?
	|	'finally' finallyExpression=XExpression
	)
	;


enum Visibility :
	 protected | public | private
;

 typeID returns types::JvmTypeReference:
 		
 		('${'ValidID':'('elemType' | 'newType')'('=>(JvmTypeReference)')}')
 		//|(=>'${''elemType' '('=>JvmTypeReference')}')
 ;

declarativeID:
	  jFaceVarID |
	  =>ValidID 
;

jFaceVarID:
	'${'(ValidID|JFACEEXPRID)'}' 
		|('${'=>ValidID ':' ('newName') '('(QualifiedName|JFACEEXPRID)')}')
 		//|('${'=>('freeName'|'newName') '('ValidID')}')
;
operandID :
	ValidID | 
	('${' =>(ValidID)'}')

;






jFaceSpecificLiteral returns xbase::XExpression:
	{jFaceSpecificLiteral}
	'${'type=('cursor'|'dollar'|'line_selection'|'date'
		|'time'|'enclosing_method'|'enclosing_method_arguments'|
		'enclosing_package'|'enclosing_project'|'enclosing_type'|
		'file'|'primary_type_name'|'return_type'|'user'|'word_selection'|'year'
	)'}'
	|=>jFaceCastExpression
;


 abstractTypeName:
 	type=referencedType | jFaceType=jFaceDeclarationType
 ;
 
 jFaceDeclarationType:
	'${'type=('array_type'|'iterable_type'|ValidID )'}'
	|('${'ValidID':'('elemType' | 'newType')'('type=( JFACEEXPRASTYPE | 'array_type'|'iterable_type' )')}')
;
 


referencedType returns types::JvmTypeReference:
	(typeID)
	|=>	JvmTypeReference
;

FeatureCallID:
	operandID | 'extends' | 'static' | 'import' | 'extension'
;

JvmFormalParameter returns types::JvmFormalParameter:
{JvmFormalParameter}	
(parameterType=referencedType | jFaceType=jFaceDeclarationType)? 
(simpleName=operandID | jFaceExpr=jFaceExpression);
	
FullJvmFormalParameter returns types::JvmFormalParameter:
{JvmFormalParameter}	
	(parameterType=referencedType | jFaceType=jFaceDeclarationType) simpleName=(declarativeID|operandID) ;


helpperClassAnnotation :
	'${' 'helper' '}' 
	class= entity 
	'${' 'endHelper' '}'
;
XLiteral returns xbase::XExpression:
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral
;

JFACEEXPRID:
	JFACEEXPRASTYPE | 'iterable_element' | 'array_element' | 'index' | 'exception_variable_name'
;

JFACEEXPRASTYPE:
	
	'array' | 'collection' | /*'iterator' |*/ 'iterable' 
;

terminal ID:
	'^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	
ArrayBrackets :
	'[]'
;
 